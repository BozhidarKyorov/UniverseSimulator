Тема на проект - Симулатор на Вселената

Моето решение е базирано на рандомизирано теглене на числа и изпозлването им за пресмятане
на вероятностите за разпад на всяка частица. Прозивлоните числа се генерират от един поток, 
който се определя в началото на програмата. За пресмятане на вероятносттите първо всеки
процент се умножава по 10000 за да се премахнат дробните части и се запазват под формата
на "скала".
Пример: нека имаме частица Х, която се разпада на множества от частици А В и С със 
следните вериятностти: 10%, 35% и 55%. 
Тогава съставяме следната скала:
1  - 10  - А 
10 - 45  - В (10+35)
45 - 100 - С (45+55)
така, ако, например, се падне число 7, то е в интервал 1 - 10 и се разпада на А,
а при 78 се - разпада на С.
Програмата е направена на този принцип, като всеки процент е умножен по 10000, за да се
премахнат дробните части и теглим число от 1 до 1000000. Това се повтаря, докато всички
останали частици са "Стабилни".

Програмата е конзолно приложение, като в самото него е включена валидация на входа и 
обратни съобщения за поясняване какъв трябва да е очаквания вход. На почти всеки избор
има опцята за приключване (quit) и спиране на програмата. Започва като се дава
опция дали "Играча" да застане в ролята на Бог или не. Ако не застане, се пуска симулацията
с една "Higgz" частица. След това се дава опцията дали да виждаме всеки тик по време на
разпада на частицата, или само тези, в които всъщност се случва разпад (тъй като вероятността
за разпад е 0.0443% отнема средно около 2000 тика преди да се случи нещо, които са просто
приниране на всички частици). Ако изберем да не гледаме всеки тик имаме опцята да изберем
честота, в която да виждаме тиковете, примерно всеки 120 тика. Ако "Играча" застане на ролята
на Бог, той избира колко и какви частици да сложи във Вселената, предоставя се списък от всички
"Нестабилни частици" и всички които не са от този списък се считат за стабилни. След това 
симулацията продължава както е обяснено горе, но с избраните от Бог частици

Разяснение на потребителските типове:

data PartSplit = PartSplit {probability :: Int, names :: [String]} deriving (Show)
        probability - вероятността да се разпадне на съответните частици
        names - лист от частиците на които да се разпадне

data PartInfo = PartInfo {name :: String, splitChance :: Int, splits :: [PartSplit]} deriving (Show)
        name - име на частицата
        splitChance - шанса да се разпадне дадената частица
        [PartSplit] - лист от всички възможностти да се разпадне частицата

Разяснение на фукниците:

main -  избиране на роля (бог или наблюдател) и извикването на фукция 
        heDoesntWantsToBeAGod ако е избран наблюдател или
        heWantsToBeAGod ако е избран бог

heDoesntWantToBeAGod - създаване на генератор за произволни числа и поток от произолни числа
        с помощща на фукция randStream, обработване на комуникацията с Играча и извикване на
        фукнция startSplitting със всички нужни аргументи (ще бъдат разяснени по късно)

heWantsToBeAGod - горе долу същото като предишната фукнция, но с допълнението на четене на 
        новите начални частици от конзолата. Първо се въвежда брой частици и след това 
        на нов ред всяка частица

startSplitting :: [String] -> [Int] -> Int -> Bool -> Maybe Int -> IO()
    Гръбнака на програмта, носи всички на гърба си.
        Първо ще обсъдим входа: 
        [String] - лист от всички частици в този тик
        [Int] - потокът от произволни числа
        Int - текущият тик
        Bool - дали да се показват всички тикове или само тези с определената честота
        Maybe Int - честота (ако е Nothing принтираме с базова честота от 10000)

        Това беше дълго, нека разлгедаме какво прави всъщност. Фукнцията рекурсивно разпада 
        всички частици от листа в частици като ги подава на splitAll заедно с потока от числа.
        След това проверява дали всички частици са стабилни. Ако не са, принтира спрямо 
        ограниенията дали всички да се принитират и честота, като на всяко извикване drop-ва
        първите вече използваните числа от потока (по 2 за всяка частица)

splitPredicate :: String -> Int -> Bool
        String - частица
        Int - процент
        Проверява дали подадена частица трябва да се разпадне като използва процента и 
        зададената за всяка частица вероятност да се разпадне. Ако е стабилна, връща False

splitParticle :: [PartSplit] -> Int -> [String]
        [PartSplit] - потребителки тип - лист от вероятносстите да се разпадне съответното множество от частици и самото множеството от частици. практически скалата от по рано
        Int - числото за сравнение по скалата
        Рекусивно проверява дали числото е по малко от съответното и ако е, връща листа от
        частици на които да се разпадне дадената

splitParticles :: String -> Int -> Int -> [String]
        String - име на частица
        Int - число за splitPredicate за проверка дали да се разпадне частица
        Int - число за splitParticle на какви частици да се разпадне спрямо скалата
        Проверява дали частица трябва да се разпадне със функция splitPredicate и ако да
        връща листа на какви частици се е разпаднала получен от splitParticle. Ако частица
        е стабила, връща лист от частицата ([particle])

predicate :: String -> [Int] -> [String]
        String - име на частица, подавано на splitParticles
        [Int] - потокът от произволни числа
        Обгъщаща функция за splitParticles за да опрости синтаксиса и, реално взима потока от
        произволни числа и подава на splitParticles първите две за сравнение с вероятностите за
        разпад и връща резултата на splitParticles

splitAll :: [Int] -> [String] -> [String]
        [Int] - потокът от произволни числа
        [String] - лист от всички частици
        Рекурсивно прилага predicate на всяка частица от листа и конкатенира резултатите от
        разпадането им. Реално e concatMap но просто предикатът не приема само един вход. Също
        премахва първите две числа от потока за да поддържа рандомизацията преди всяка 
        рекурсивна стъпка

areAllStable :: [String] -> Bool
        [String] - лист от частици
        Проверява дали всички частици са стабилни
